package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.SneakyThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.sql.DataSource;
import java.sql.*;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;


@ExtendWith(MockitoExtension.class)
public class VulnerabilityRepositoryTest {

    @Mock DataSource dataSource;
    @Mock Connection mockConnection;
    @Mock PreparedStatement mockPS;
    @Mock ResultSet mockRS;

    VulnerabilityRepository repository;

    @SneakyThrows
    @BeforeEach
    void initializeMocks(){
        when(mockPS.executeQuery()).thenReturn(mockRS);
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPS);
        when(dataSource.getConnection()).thenReturn(mockConnection);

        repository = new VulnerabilityRepository(dataSource);
    }

    @SneakyThrows
    @Test
    void testGetCveIdNotFoundReturnsEmptyString() {
        String expectedId = "";

        when(mockRS.next()).thenReturn(false);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }

    @SneakyThrows
    @Test
    void testGetCveIdReturnsCveIdWhenFound() {
        String expectedId = "CVE_1234_5678";

        when(mockRS.next()).thenReturn(true);
        when(mockRS.getString("cve_id")).thenReturn(expectedId);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }

    // todo what follows are a bunch of old tests that need to be properly converted


//    @org.junit.Test
//    public void testGetCompositeVulnerability() throws SQLException {
//        // Set up the behavior of the mocks
//        when(res.next()).thenReturn(true, false, true);
//        when(res.getInt(anyString())).thenReturn(1);
//        when(res.getString(anyString())).thenReturn("1");
//        when(res.getTimestamp(anyString())).thenReturn(new Timestamp(System.currentTimeMillis()));
//
//        DeprecatedCompositeVulnerability vuln = dbh.getCompositeVulnerability("1");
//
//        assertNotNull(vuln);
//
//    }

//    @org.junit.Test
//    public void insertOrUpdateVulnerabilityFullTest() {
//        try{
//            when(conn.prepareStatement(anyString(), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(pstmt);
//            when(pstmt.getGeneratedKeys()).thenReturn(res);
//            when(res.next()).thenReturn(true);
//            when(res.getInt(1)).thenReturn(1);
//
//            RawVulnerability rawVuln = new RawVulnerability(1, "CVE-2023-1111", "desc", offset(-1), offset(1), offset(-10), "example.com");
//
//            Set<RawVulnerability> rawVulns = new HashSet<>();
//            rawVulns.add(rawVuln);
//
//            DeprecatedCompositeVulnerability vuln = new DeprecatedCompositeVulnerability(rawVuln);
//            vuln.setPotentialSources(rawVulns);
//
//            // Call the method to be tested
//            int result = dbh.insertOrUpdateVulnerabilityFull(vuln);
//
//
//            // Assert the result
//            assertEquals(1, result);
//        } catch (SQLException e) {
//            throw new RuntimeException(e);
//        }
//    }


//    @org.junit.Test
//    public void insertDescriptionTest() throws SQLException {
//        when(res.next()).thenReturn(true);
//        when(res.getInt(anyInt())).thenReturn(1);
//        when(pstmt.getGeneratedKeys()).thenReturn(res);
//        Set<RawVulnerability> set = new HashSet<>();
//        set.add(new RawVulnerability(1, "CVE-2021-1234", "Description", null, null, null, ""));
//        DeprecatedCompositeDescription desc = new DeprecatedCompositeDescription("cve-1", "desc", set);
//
//        dbh.insertDescription(desc);
//
//        verify(conn).setAutoCommit(false);
//        verify(conn).commit();
//        verify(pstmt).executeBatch();
//        verify(pstmt).addBatch();
//        verify(pstmt).setInt(1, 1);
//        verify(pstmt).setInt(2, 1);
//
//
//    }


}
