package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;


@ExtendWith(MockitoExtension.class)
public class VulnerabilityRepositoryTest {

    @Mock DataSource dataSource;
    @Mock Connection mockConnection;
    @Mock PreparedStatement mockPS;
    @Mock ResultSet mockRS;

    VulnerabilityRepository repository;

    @SneakyThrows
    @BeforeEach
    void initializeMocks(){
        when(mockPS.executeQuery()).thenReturn(mockRS);
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPS);
        when(dataSource.getConnection()).thenReturn(mockConnection);

        repository = new VulnerabilityRepository(dataSource);
    }

    @SneakyThrows
    @Test
    void testGetCveIdNotFoundReturnsEmptyString() {
        String expectedId = "";

        when(mockRS.next()).thenReturn(false);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }

    @SneakyThrows
    @Test
    void testGetCveIdReturnsCveIdWhenFound() {
        String expectedId = "CVE_1234_5678";

        when(mockRS.next()).thenReturn(true);
        when(mockRS.getString("cve_id")).thenReturn(expectedId);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }

    // todo what follows are a bunch of old tests that need to be properly converted


//    @org.junit.Test
//    public void testGetCompositeVulnerability() throws SQLException {
//        // Set up the behavior of the mocks
//        when(res.next()).thenReturn(true, false, true);
//        when(res.getInt(anyString())).thenReturn(1);
//        when(res.getString(anyString())).thenReturn("1");
//        when(res.getTimestamp(anyString())).thenReturn(new Timestamp(System.currentTimeMillis()));
//
//        DeprecatedCompositeVulnerability vuln = dbh.getCompositeVulnerability("1");
//
//        assertNotNull(vuln);
//
//    }

//    @org.junit.Test
//    public void insertOrUpdateVulnerabilityFullTest() {
//        try{
//            when(conn.prepareStatement(anyString(), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(pstmt);
//            when(pstmt.getGeneratedKeys()).thenReturn(res);
//            when(res.next()).thenReturn(true);
//            when(res.getInt(1)).thenReturn(1);
//
//            RawVulnerability rawVuln = new RawVulnerability(1, "CVE-2023-1111", "desc", offset(-1), offset(1), offset(-10), "example.com");
//
//            Set<RawVulnerability> rawVulns = new HashSet<>();
//            rawVulns.add(rawVuln);
//
//            DeprecatedCompositeVulnerability vuln = new DeprecatedCompositeVulnerability(rawVuln);
//            vuln.setPotentialSources(rawVulns);
//
//            // Call the method to be tested
//            int result = dbh.insertOrUpdateVulnerabilityFull(vuln);
//
//
//            // Assert the result
//            assertEquals(1, result);
//        } catch (SQLException e) {
//            throw new RuntimeException(e);
//        }
//    }


//    @org.junit.Test
//    public void insertDescriptionTest() throws SQLException {
//        when(res.next()).thenReturn(true);
//        when(res.getInt(anyInt())).thenReturn(1);
//        when(pstmt.getGeneratedKeys()).thenReturn(res);
//        Set<RawVulnerability> set = new HashSet<>();
//        set.add(new RawVulnerability(1, "CVE-2021-1234", "Description", null, null, null, ""));
//        DeprecatedCompositeDescription desc = new DeprecatedCompositeDescription("cve-1", "desc", set);
//
//        dbh.insertDescription(desc);
//
//        verify(conn).setAutoCommit(false);
//        verify(conn).commit();
//        verify(pstmt).executeBatch();
//        verify(pstmt).addBatch();
//        verify(pstmt).setInt(1, 1);
//        verify(pstmt).setInt(2, 1);
//
//
//    }

    //	@Test
//    public void getAllCompositeVulnerabilitiesTest() throws SQLException {
//        // Prepare test data
//        int maxVulnerabilities = 5;
//        int expectedVulnerabilities = 3;
//
//        // Mock the database interactions
//        when(conn.prepareStatement(anyString())).thenReturn(pstmt);
//        when(pstmt.executeQuery()).thenReturn(res);
//        when(res.next()).thenReturn(true, true, true, false); // Simulate 3 rows returned from the query, followed by an extra call returning false
//        when(res.getInt("vuln_id")).thenReturn(1, 2, 3);
//        when(res.getString("cve_id")).thenReturn("CVE-2021-001", "CVE-2021-002", "CVE-2021-003");
//        when(res.getString("description")).thenReturn("Description 1", "Description 2", "Description 3");
//
//        // Call the method under test
//        List<CompositeVulnerability> result = dbh.getAllCompositeVulnerabilities(maxVulnerabilities);
//
//        // Verify the expected interactions
//        verify(conn).prepareStatement(anyString());
//        verify(pstmt).executeQuery();
//        verify(res, times(expectedVulnerabilities)).getInt("vuln_id");
//        verify(res, times(expectedVulnerabilities)).getString("cve_id");
//        verify(res, times(expectedVulnerabilities)).getString("description");
//
//        // Verify the result
//        Assertions.assertEquals(expectedVulnerabilities, result.size());
//    }



//    //	@Test
//    public void getSpecificCompositeVulnerabilitiesTest() throws SQLException{
//        List<String> cveIds = new ArrayList<>();
//
//        String cveId1 = "CVE-2021-20105";
//        String description1 = "Machform prior to version 16 is vulnerable to an open redirect in Safari_init.php due to an improperly sanitized 'ref' parameter.";
//
//        String cveId2 = "CVE-2016-4361";
//        String description2 = "HPE LoadRunner 11.52 through patch 3, 12.00 through patch 1, 12.01 through patch 3, 12.02 through patch 2, and 12.50 through patch 3 and Performance Center 11.52 through patch 3, 12.00 through patch 1, 12.01 through patch 3, 12.20 through patch 2, and 12.50 through patch 1 allow remote attackers to cause a denial of service via unspecified vectors.";
//
//        String cveId3 = "CVE-2019-3915";
//        String description3 = "Authentication Bypass by Capture-replay vulnerability in Verizon Fios Quantum Gateway (G1100) firmware version 02.01.00.05 allows an unauthenticated attacker with adjacent network access to intercept and replay login requests to gain access to the administrative web interface.";
//
//        cveIds.add(cveId1);
//        cveIds.add(cveId2);
//        cveIds.add(cveId3);
//
//        List<Integer> vvIds = new ArrayList<>();
//        vvIds.add(1);
//        vvIds.add(2);
//        vvIds.add(3);
//
//        // Mock the database interactions
//        when(conn.prepareStatement(anyString())).thenReturn(pstmt);
//        when(pstmt.executeQuery()).thenReturn(res);
//        when(res.next()).thenReturn(true, true, true, false);
//        when(res.getInt("vuln_id")).thenReturn(1, 2, 3);
//        when(res.getString("description")).thenReturn(description1, description2, description3);
//
//        List<CompositeVulnerability> vulnList = dbh.getSpecificCompositeVulnerabilities(vvIds);
//        Assertions.assertEquals(vulnList.size(), cveIds.size());
//
//        CompositeVulnerability vuln1 = vulnList.get(0);
//        CompositeVulnerability vuln2 = vulnList.get(1);
//        CompositeVulnerability vuln3 = vulnList.get(2);
//
//        Assertions.assertEquals(vuln1.getDescription(), description1);
//        Assertions.assertEquals(vuln2.getDescription(), description2);
//        Assertions.assertEquals(vuln3.getDescription(), description3);
//    }

}
