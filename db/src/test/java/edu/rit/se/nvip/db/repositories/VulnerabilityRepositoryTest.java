/ **
* Copyright 2021 Rochester Institute of Technology (RIT). Developed with
* government support under contract 70RCSA22C00000008 awarded by the United
* States Department of Homeland Security for Cybersecurity and Infrastructure Security Agency.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the “Software”), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
* /

package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.model.CompositeDescription;
import edu.rit.se.nvip.db.model.CompositeVulnerability;
import edu.rit.se.nvip.db.model.RawVulnerability;
import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;


@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class VulnerabilityRepositoryTest {

    @Mock DataSource dataSource;
    @Mock Connection mockConnection;
    @Mock PreparedStatement mockPS;
    @Mock ResultSet mockRS;

    VulnerabilityRepository repository;

    @SneakyThrows
    @BeforeEach
    void initializeMocks(){
        when(mockPS.executeQuery()).thenReturn(mockRS);
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPS);
        when(dataSource.getConnection()).thenReturn(mockConnection);

        repository = new VulnerabilityRepository(dataSource);
    }

    @SneakyThrows
    @Test
    void testGetCveIdNotFoundReturnsEmptyString() {
        String expectedId = "";

        when(mockRS.next()).thenReturn(false);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }

    @SneakyThrows
    @Test
    void testGetCveIdReturnsCveIdWhenFound() {
        String expectedId = "CVE_1234_5678";

        when(mockRS.next()).thenReturn(true);
        when(mockRS.getString("cve_id")).thenReturn(expectedId);

        String cveId = repository.getCveId("1");

        assertEquals(expectedId, cveId);
    }


    @SneakyThrows
    @Test
    public void testGetCompositeVulnerability() {
        // Set up the behavior of the mocks
        when(mockRS.next()).thenReturn(true, false, true);
        when(mockRS.getInt(anyString())).thenReturn(1);
        when(mockRS.getString(anyString())).thenReturn("1");
        when(mockRS.getTimestamp(anyString())).thenReturn(new Timestamp(System.currentTimeMillis()));

        CompositeVulnerability vuln = repository.getCompositeVulnerability("1");

        assertNotNull(vuln);

    }

    // helper field and func for timestamp checks
    private final long dummyMillis = System.currentTimeMillis();
    private Timestamp offset(int nHours) {
        return new Timestamp(dummyMillis + nHours*3600L*1000);
    }

    @Test
    @SneakyThrows
    public void insertOrUpdateVulnerabilityFullTest() {
        try{
            when(mockConnection.prepareStatement(anyString(), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(mockPS);
            when(mockPS.getGeneratedKeys()).thenReturn(mockRS);
            when(mockRS.next()).thenReturn(true);
            when(mockRS.getInt(1)).thenReturn(1);

            RawVulnerability rawVuln = new RawVulnerability(1, "CVE-2023-1111", "desc", offset(-1), offset(1), offset(-10), "example.com");

            Set<RawVulnerability> rawVulns = new HashSet<>();
            rawVulns.add(rawVuln);

            CompositeVulnerability vuln = new CompositeVulnerability(rawVuln);
            vuln.setPotentialSources(rawVulns);

            // Call the method to be tested
            int result = repository.insertOrUpdateVulnerabilityFull(vuln, true);


            // Assert the result
            assertEquals(1, result);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }


    @Test
    @SneakyThrows
    public void insertDescriptionTest() {
        when(mockRS.next()).thenReturn(true);
        when(mockRS.getInt(anyInt())).thenReturn(1);
        when(mockPS.getGeneratedKeys()).thenReturn(mockRS);
        Set<RawVulnerability> set = new HashSet<>();
        set.add(new RawVulnerability(1, "CVE-2021-1234", "Description", null, null, null, ""));
        CompositeDescription desc = new CompositeDescription("cve-1", "desc", set);

        repository.insertDescription(desc);

        verify(mockConnection).setAutoCommit(false);
        verify(mockConnection).commit();
        verify(mockPS).executeBatch();
        verify(mockPS).addBatch();
        verify(mockPS).setInt(1, 1);
        verify(mockPS).setInt(2, 1);


    }

    @Test
    @SneakyThrows
    public void getAllCompositeVulnerabilitiesTest() {
        // Prepare test data
        int maxVulnerabilities = 5;
        int expectedVulnerabilities = 3;

        // Mock the database interactions
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPS);
        when(mockPS.executeQuery()).thenReturn(mockRS);
        when(mockRS.next()).thenReturn(true, true, true, false); // Simulate 3 rows returned from the query, followed by an extra call returning false
        when(mockRS.getInt("vuln_id")).thenReturn(1, 2, 3);
        when(mockRS.getString("cve_id")).thenReturn("CVE-2021-001", "CVE-2021-002", "CVE-2021-003");
        when(mockRS.getString("description")).thenReturn("Description 1", "Description 2", "Description 3");

        // Call the method under test
        List<CompositeVulnerability> result = repository.getAllCompositeVulnerabilities(maxVulnerabilities);

        // Verify the expected interactions
        verify(mockConnection).prepareStatement(anyString());
        verify(mockPS).executeQuery();
        verify(mockRS, times(expectedVulnerabilities)).getInt("vuln_id");
        verify(mockRS, times(expectedVulnerabilities)).getString("cve_id");
        verify(mockRS, times(expectedVulnerabilities)).getString("description");

        // Verify the result
        Assertions.assertEquals(expectedVulnerabilities, result.size());
    }



    @Test
    @SneakyThrows
    public void getSpecificCompositeVulnerabilitiesTest(){
        List<String> cveIds = new ArrayList<>();
        List<String> descriptions = new ArrayList<>();

        String cveId1 = "CVE-2021-20105";
        String description1 = "Machform prior to version 16 is vulnerable to an open redirect in Safari_init.php due to an improperly sanitized 'ref' parameter.";

        String cveId2 = "CVE-2016-4361";
        String description2 = "HPE LoadRunner 11.52 through patch 3, 12.00 through patch 1, 12.01 through patch 3, 12.02 through patch 2, and 12.50 through patch 3 and Performance Center 11.52 through patch 3, 12.00 through patch 1, 12.01 through patch 3, 12.20 through patch 2, and 12.50 through patch 1 allow remote attackers to cause a denial of service via unspecified vectors.";

        String cveId3 = "CVE-2019-3915";
        String description3 = "Authentication Bypass by Capture-replay vulnerability in Verizon Fios Quantum Gateway (G1100) firmware version 02.01.00.05 allows an unauthenticated attacker with adjacent network access to intercept and replay login requests to gain access to the administrative web interface.";

        cveIds.add(cveId1);
        cveIds.add(cveId2);
        cveIds.add(cveId3);

        descriptions.add(description1);
        descriptions.add(description2);
        descriptions.add(description3);

        List<Integer> vvIds = new ArrayList<>();
        vvIds.add(1);
        vvIds.add(2);
        vvIds.add(3);

        // Mock the database interactions
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPS);
        when(mockPS.executeQuery()).thenReturn(mockRS);
        when(mockRS.next()).thenReturn(true, true, true, false);
        when(mockRS.getInt("vuln_id")).thenReturn(1, 2, 3);
        when(mockRS.getString("description")).thenReturn(description1, description2, description3);

        // Test vulns
        for (int i = 0; i < cveIds.size(); i++) {
            String cveId = cveIds.get(i);
            String description = descriptions.get(i);
            CompositeVulnerability vuln = repository.getSpecificCompositeVulnerability(vvIds.get(i));
            assertNotNull(vuln);
            assertEquals(vuln.getDescription(), description);
        }
    }

}
