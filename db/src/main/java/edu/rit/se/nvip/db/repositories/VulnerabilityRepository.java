/**
* Copyright 2021 Rochester Institute of Technology (RIT). Developed with
* government support under contract 70RCSA22C00000008 awarded by the United
* States Department of Homeland Security for Cybersecurity and Infrastructure Security Agency.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the “Software”), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.DatabaseHelper;
import edu.rit.se.nvip.db.model.CompositeDescription;
import edu.rit.se.nvip.db.model.CompositeVulnerability;
import edu.rit.se.nvip.db.model.RawVulnerability;
import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

@Slf4j
@RequiredArgsConstructor
public class VulnerabilityRepository {

    private final DataSource dataSource;

    private final String selectCVEIdSql = "SELECT cve_id FROM vulnerability WHERE vuln_id = ?";

    public CompositeVulnerability getCompositeVulnerability(String cveId) {
        RawDescriptionRepository rawRepo = new RawDescriptionRepository(this.dataSource);
        Set<RawVulnerability> usedRawVulns = rawRepo.getUsedRawVulnerabilities(cveId);
        return getSummaryVulnerability(cveId, usedRawVulns);
    }

    private String getCompVuln = "SELECT v.vuln_id, v.created_date, vv.published_date, vv.last_modified_date, d.description_id, d.description, d.created_date AS description_date, d.gpt_func " +
            "FROM vulnerability AS v " +
            "INNER JOIN vulnerabilityversion AS vv ON v.vuln_version_id = vv.vuln_version_id " +
            "INNER JOIN description AS d ON vv.description_id = d.description_id " +
            "WHERE v.cve_id = ?";

    // very hacky to use the rawVulns as an arg, there's a better way to handle this join
    private CompositeVulnerability getSummaryVulnerability(String cveId, Set<RawVulnerability> rawVulns) {
        CompositeVulnerability vuln = null;
        try (Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.prepareStatement(getCompVuln)) {
            pstmt.setString(1, cveId);
            ResultSet res = pstmt.executeQuery();
            if (res.next()) {
                CompositeDescription compDes = new CompositeDescription(
                        res.getInt("description_id"),
                        cveId,
                        res.getString("description"),
                        res.getTimestamp("description_date"),
                        res.getString("gpt_func"),
                        rawVulns
                );
                vuln = new CompositeVulnerability(
                        cveId,
                        res.getInt("vuln_id"),
                        compDes,
                        res.getTimestamp("published_date"),
                        res.getTimestamp("last_modified_date"),
                        res.getTimestamp("created_date")
                );
            }
        } catch (SQLException ex) {
            log.error("Error retrieving vulnerability {}.\n{}", cveId, ex);
            return null;
        }
        return vuln;
    }

    /**
     * Collect a CVE ID from the Vulnerability table by Vuln ID
     *
     * @param vulnId
     * @return
     */
    public String getCveId(String vulnId) {

        String cve_id = "";

        try (Connection connection = dataSource.getConnection()) {

            PreparedStatement pstmt = connection.prepareStatement(selectCVEIdSql);
            pstmt.setInt(1, Integer.parseInt(vulnId));
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                cve_id = rs.getString("cve_id");
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        return cve_id;
    }


    private static final String INSERT_DESCRIPTION = "INSERT INTO description (description, created_date, gpt_func, cve_id, is_user_generated) VALUES (?, ?, ?, ?, ?)";
    private static final String INSERT_JT = "INSERT INTO rawdescriptionjt (description_id, raw_description_id) VALUES (?, ?)";
    private static final String INSERT_VULN_VERSION = "INSERT INTO vulnerabilityversion (cve_id, description_id, created_date, published_date, last_modified_date) VALUES (?, ?, NOW(), ?, ?)";
    private static final String SELECT_PREV_VERSION_KEYS = "SELECT vdo_set_id, cpe_set_id FROM vulnerabilityversion WHERE cve_id = ? ORDER BY created_date DESC LIMIT 1";
    private static final String COPY_PREV_VERSION_KEYS = "UPDATE vulnerabilityversion SET vdo_set_id = ?, cpe_set_id = ? WHERE vuln_version_id = ?";
    private static final String INSERT_VULNERABILITY = "INSERT INTO vulnerability (cve_id, created_date, vuln_version_id) VALUES (?, NOW(), ?)";
    private static final String UPDATE_VULNERABILITY = "UPDATE vulnerability SET vuln_version_id = ? WHERE cve_id = ?";
    private static final String DELETE_JOB = "DELETE FROM cvejobtrack WHERE cve_id = ?";


    /**
     * Inserts, updates, or does nothing for a composite vulnerability based on its reconciliation status
     * @param vuln composite vulnerability
     * @return 1 if inserted/updated, 0 if skipped, -1 if error
     */
    public int insertOrUpdateVulnerabilityFull(CompositeVulnerability vuln, boolean newVuln) {


        try (Connection conn = dataSource.getConnection();
             PreparedStatement descriptionStatement = conn.prepareStatement(INSERT_DESCRIPTION, Statement.RETURN_GENERATED_KEYS);
             PreparedStatement jtStatement = conn.prepareStatement(INSERT_JT);
             PreparedStatement vvStatement = conn.prepareStatement(INSERT_VULN_VERSION, Statement.RETURN_GENERATED_KEYS);
             PreparedStatement prevVersionsStatement = conn.prepareStatement(SELECT_PREV_VERSION_KEYS);
             PreparedStatement copyStatement = conn.prepareStatement(COPY_PREV_VERSION_KEYS);
             PreparedStatement vulnStatement = conn.prepareStatement(newVuln ? INSERT_VULNERABILITY : UPDATE_VULNERABILITY);
             PreparedStatement jobStatement = conn.prepareStatement(DELETE_JOB)) {
            // handle all these atomically
            conn.setAutoCommit(false);
            // insert into description table
            populateDescriptionInsert(descriptionStatement, vuln.getSystemDescription());
            descriptionStatement.executeUpdate();
            // get generated description id
            ResultSet rs = descriptionStatement.getGeneratedKeys();
            if (rs.next()) {
                vuln.setDescriptionId(rs.getInt(1));
            } else {
                // Pretty sure an exception would have been thrown by now anyway, but just in case...
                log.error("ERROR: Failure in inserting to the description table");
                throw new SQLException();
            }
            // batch insert into joint table
            for (RawVulnerability rawVuln : vuln.getComponents()) {
                populateJTInsert(jtStatement, vuln.getSystemDescription(), rawVuln);
                jtStatement.addBatch();
            }
            jtStatement.executeBatch();
            // insert new version row
            populateVulnVersionInsert(vvStatement, vuln);
            vvStatement.executeUpdate();
            rs = vvStatement.getGeneratedKeys();
            if (rs.next()) {
//                log.info("Column name: {}", rs.getMetaData().getColumnName(1));
                int versionId = rs.getInt(1);
//                int versionIdByName = rs.getInt("vuln_version_id");
//                log.info("rs.getInt(1) returned {}\nrs.getInt(\"vuln_version_id\") returned {}", versionId, versionIdByName);
                vuln.setVersionId(versionId-1);
            }
            // if we're updating, copy over the vdo/cpe pointers to this new version
            if (!newVuln) {
                prevVersionsStatement.setString(1, vuln.getCveId());
                rs = prevVersionsStatement.executeQuery();
                if(rs.next()) {
                    int vdoSetId = rs.getInt("vdo_set_id");
                    int cpeSetId = rs.getInt("cpe_set_id");

                    copyStatement.setInt(1, vdoSetId);
                    copyStatement.setInt(2, cpeSetId);
                    copyStatement.setInt(3, vuln.getVersionId());
                    log.info("Updating cve {} with vdo_set: {} and cpe_set_id {}", vuln.getVersionId(), vdoSetId, cpeSetId);
                    copyStatement.executeUpdate();
                } else {
                    log.error("Unable to copy vdo set and cpe set: No results in result set!");
                }
            }
            // insert new vuln row or update version pointer
            if (!newVuln) {
                log.info("Updating Vulnerability: {}", vuln.getCveId());
                populateVulnUpdate(vulnStatement, vuln);
            } else {
                log.info("Creating Vulnerability: {}", vuln.getCveId());
                populateVulnInsert(vulnStatement, vuln);
            }
            vulnStatement.executeUpdate();
            // remove job
            populateJobDelete(jobStatement, vuln);
            jobStatement.executeUpdate();
            // execute atomically
            conn.commit();
        } catch (SQLException ex) {
            log.error("ERROR while {} {}.\n{}", !newVuln ? "updating" : "inserting", vuln.getCveId(), ex);
            return -1;
        }
        return 1;
    }



    public void insertDescription(CompositeDescription compDesc) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement descriptionStatement = conn.prepareStatement(INSERT_DESCRIPTION);
             PreparedStatement jtStatement = conn.prepareStatement(INSERT_JT)) {
            conn.setAutoCommit(false);
            populateDescriptionInsert(descriptionStatement, compDesc);
            descriptionStatement.executeUpdate();
            ResultSet rs = descriptionStatement.getGeneratedKeys();
            if (rs.next()) {
                compDesc.setId(rs.getInt(1));
            } else {
                // Pretty sure an exception would have been thrown by now anyway, but just in case...
                log.error("ERROR: Failure in inserting a description for {}", compDesc.getCveId());
                throw new SQLException();
            }
            for (RawVulnerability rawVuln : compDesc.getSources()) {
                populateJTInsert(jtStatement, compDesc, rawVuln);
                jtStatement.addBatch();
            }
            jtStatement.executeBatch();
            conn.commit();
        } catch (SQLException ex) {
            log.error("Error while inserting description for {}", compDesc.getCveId());
        }
    }

    private void populateDescriptionInsert(PreparedStatement descriptionStatement, CompositeDescription compDesc) throws SQLException {
        descriptionStatement.setString(1, compDesc.getDescription());
        descriptionStatement.setTimestamp(2, compDesc.getCreatedDate());
        descriptionStatement.setString(3, compDesc.getBuildString());
        descriptionStatement.setString(4, compDesc.getCveId());
        descriptionStatement.setInt(5, compDesc.isUserGenerated() ? 1 : 0);
    }

    private void populateJTInsert(PreparedStatement jtStatement, CompositeDescription compDesc, RawVulnerability rawVuln) throws SQLException {
        jtStatement.setInt(1, compDesc.getId());
        jtStatement.setInt(2, rawVuln.getId());
    }

    private void populateVulnInsert(PreparedStatement vulnStatement, CompositeVulnerability vuln) throws SQLException {
        vulnStatement.setString(1, vuln.getCveId());
        vulnStatement.setInt(2, vuln.getVersionId());
    }

    private void populateVulnUpdate(PreparedStatement vulnStatement, CompositeVulnerability vuln) throws SQLException {
        vulnStatement.setInt(1, vuln.getVersionId());
        vulnStatement.setString(2, vuln.getCveId());
    }

    private void populateVulnVersionInsert(PreparedStatement vvStatement, CompositeVulnerability vuln) throws SQLException{
        vvStatement.setString(1, vuln.getCveId());
        vvStatement.setInt(2, vuln.getDescriptionId());
        vvStatement.setTimestamp(3, vuln.getPublishDate());
        vvStatement.setTimestamp(4, vuln.getLastModifiedDate());
    }

    private void populateJobDelete(PreparedStatement jobStatement, CompositeVulnerability vuln) throws SQLException {
        jobStatement.setString(1, vuln.getCveId());
    }


    private final String selectVulnerabilitySql = "SELECT v.vuln_id, v.cve_id, d.description, vv.vuln_version_id " +
            "FROM vulnerability AS v JOIN vulnerabilityversion AS vv ON v.vuln_version_id = vv.vuln_version_id " +
            "JOIN description AS d ON vv.description_id = d.description_id;";

    /**
     * Gets list of vulnerabilities from the database, formats them into CompositeVulnerability objects,
     * and limits the returned list to maxVulnerabilities size.
     *
     * @param maxVulnerabilities max number of vulnerabilities to get
     * @return list of fetched vulnerabilities
     */
    public List<CompositeVulnerability> getAllCompositeVulnerabilities(int maxVulnerabilities) {
        ArrayList<CompositeVulnerability> vulnList = new ArrayList<>();
        synchronized (DatabaseHelper.class) {
            int vulnId, vulnVersionId;
            String cveId, description;
            try (Connection connection = dataSource.getConnection()) {
                PreparedStatement pstmt = connection.prepareStatement(selectVulnerabilitySql);
                ResultSet rs = pstmt.executeQuery();

                int vulnCount = 0;
                // Iterate over result set until there are no results left or vulnCount >= maxVulnerabilities
                while (rs.next() && (maxVulnerabilities <= 0 || vulnCount < maxVulnerabilities)) {
                    vulnId = rs.getInt("vuln_id");
                    cveId = rs.getString("cve_id");
                    description = rs.getString("description");
                    vulnVersionId = rs.getInt("vuln_version_id");

                    CompositeVulnerability vulnerability = new CompositeVulnerability(
                            vulnId,
                            cveId,
                            description,
                            CompositeVulnerability.ReconciliationStatus.UPDATED
                    );
                    vulnerability.setVersionId(vulnVersionId);
                    vulnList.add(vulnerability);
                    vulnCount++;
                }
                log.info("Successfully loaded {} existing CVE items from DB!", vulnList.size());
            } catch (Exception e) {
                log.error("Error while getting existing vulnerabilities from DB\nException: {}", e.getMessage());
                log.error("This is a serious error! Product Name Extraction will not be able to proceed! Exiting...");
                System.exit(1);
            }
        }

        return vulnList;
    }


    private final String selectSpecificVulnerabilitySql = "SELECT v.vuln_id, v.cve_id, d.description " +
            "FROM vulnerability AS v JOIN vulnerabilityversion AS vv on v.vuln_version_id = vv.vuln_version_id " +
            "JOIN description AS d ON vv.description_id = d.description_id WHERE vv.vuln_version_id = ?;";

    /**
     * Gets list of specific vulnerabilities by their CVE IDs from the database,
     * formats them into CompositeVulnerability objects, and returns the list.
     *
     * @param vulnVersionId list of CVEs to be pulled from database
     * @return list of fetched vulnerabilities
     */
    public CompositeVulnerability getSpecificCompositeVulnerability(int vulnVersionId){
        ArrayList<CompositeVulnerability> vulnList = new ArrayList<>();
        synchronized (DatabaseHelper.class) {
            try (Connection connection = dataSource.getConnection()) {

                PreparedStatement pstmt = connection.prepareStatement(selectSpecificVulnerabilitySql);
                pstmt.setInt(1, vulnVersionId);

                ResultSet rs = pstmt.executeQuery();

                if (rs.next()) {
                    int vulnId = rs.getInt("vuln_id");
                    String description = rs.getString("description");
                    String cveId = rs.getString("cve_id");

                    CompositeVulnerability vulnerability = new CompositeVulnerability(
                            vulnId,
                            cveId,
                            description,
                            CompositeVulnerability.ReconciliationStatus.UPDATED
                    );
                    vulnerability.setVersionId(vulnVersionId);
                    return vulnerability;
                } else log.warn("CVE with version ID {} not found in the DB!", vulnVersionId);
            } catch (Exception e) {
                log.error("Error while getting existing vulnerabilities from DB\nException: {}", e.getMessage());
                log.error("This is a serious error! Product Name Extraction will not be able to proceed! Exiting...");
                System.exit(1);
            }
        }

        return null;
    }



    private final String getCvesSql = "SELECT cve_id, vuln_version_id FROM vulnerability LIMIT ?;";

    public List<Integer> getCves(int cveLimit) {
        ArrayList<Integer> versionIds = new ArrayList<>();
        try (Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.prepareStatement(getCvesSql)) {
            pstmt.setInt(1, cveLimit);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                versionIds.add(rs.getInt("vuln_version_id"));
            }
        } catch (Exception e) {
            log.error("ERROR: Failed to get CVEs: {}", e.toString());
        }
        return versionIds;
    }

    private final String getCveIdFromVulnVersion = "SELECT cve_id FROM vulnerabilityversion WHERE vuln_version_id = ?";
    public String getCveIdFromVulnVersion(int vulnVersionId) {
        try (Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.prepareStatement(getCveIdFromVulnVersion)) {
            pstmt.setInt(1, vulnVersionId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getString("cve_id");
            }
        } catch (SQLException ex) {
            log.error("ERROR: Failed to get CVE ID for vuln version {}.\n", vulnVersionId, ex);
        }
        return null;
    }
}
