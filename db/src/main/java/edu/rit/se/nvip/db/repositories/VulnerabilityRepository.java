package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.DatabaseHelper;
import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RequiredArgsConstructor
public class VulnerabilityRepository {

    private final DataSource dataSource;

    private Map<String, Vulnerability> existingVulnMap = new HashMap<>();

    private final String selectCVEIdSql = "SELECT cve_id FROM vulnerability WHERE vuln_id = ?";

    /**
     * Get existing vulnerabilities hash map. This method was added to improve
     * DatabaseHelper, NOT to query each CVEID during a CVE update! Existing
     * vulnerabilities are read only once, and this hash map is queried during
     * individual update operations!
     *
     * @return
     */
    public Map<String, Vulnerability> getExistingVulnerabilities() {

        if (existingVulnMap.size() == 0) {
            synchronized (DatabaseHelper.class) {
                if (existingVulnMap.size() == 0) {
                    int vulnId;
                    String cveId, description, createdDate;
                    int existAtNvd, existAtMitre;
                    existingVulnMap = new HashMap<>();
                    try (Connection connection = dataSource.getConnection()) {

                        String selectSql = "SELECT vuln_id, cve_id, description, created_date, exists_at_nvd, exists_at_mitre from vulnerability";
                        PreparedStatement pstmt = connection.prepareStatement(selectSql);
                        ResultSet rs = pstmt.executeQuery();

                        while (rs.next()) {
                            vulnId = rs.getInt("vuln_id");
                            cveId = rs.getString("cve_id");
                            description = rs.getString("description");
                            createdDate = rs.getString("created_date");
                            existAtNvd = rs.getInt("exists_at_nvd");
                            existAtMitre = rs.getInt("exists_at_mitre");
                            Vulnerability existingVulnInfo = new Vulnerability(vulnId, cveId, description, existAtNvd, existAtMitre,
                                    createdDate);
                            existingVulnMap.put(cveId, existingVulnInfo);
                        }
                        log.info("NVIP has loaded {} existing CVE items from DB!", existingVulnMap.size());
                    } catch (Exception e) {
                        log.error("Error while getting existing vulnerabilities from DB\nException: {}", e.getMessage());
                        log.error(
                                "This is a serious error! NVIP will not be able to decide whether to insert or update! Exiting...");
                        System.exit(1);
                    }
                }
            }
        } else {
            log.warn("NVIP has loaded {} existing CVE items from memory!", existingVulnMap.size());
        }

        return existingVulnMap;
    }

    /**
     * Collect a CVE ID from the Vulnerability table by Vuln ID
     *
     * @param vulnId
     * @return
     */
    public String getCveId(String vulnId) {

        String cve_id = "";

        try (Connection connection = dataSource.getConnection()) {

            PreparedStatement pstmt = connection.prepareStatement(selectCVEIdSql);
            pstmt.setInt(1, Integer.parseInt(vulnId));
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                cve_id = rs.getString("cve_id");
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        return cve_id;
    }
}
