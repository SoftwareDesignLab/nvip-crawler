package edu.rit.se.nvip.db.repositories;

import edu.rit.se.nvip.db.DatabaseHelper;
import edu.rit.se.nvip.db.model.CompositeDescription;
import edu.rit.se.nvip.db.model.CompositeVulnerability;
import edu.rit.se.nvip.db.model.RawVulnerability;
import edu.rit.se.nvip.db.model.Vulnerability;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sql.DataSource;
import java.sql.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RequiredArgsConstructor
public class VulnerabilityRepository {

    private final DataSource dataSource;

    private Map<String, Vulnerability> existingVulnMap = new HashMap<>();

    private final String selectCVEIdSql = "SELECT cve_id FROM vulnerability WHERE vuln_id = ?";

    /**
     * Get existing vulnerabilities hash map. This method was added to improve
     * DatabaseHelper, NOT to query each CVEID during a CVE update! Existing
     * vulnerabilities are read only once, and this hash map is queried during
     * individual update operations!
     *
     * @return
     */
    public Map<String, Vulnerability> getExistingVulnerabilities() {

        if (existingVulnMap.size() == 0) {
            synchronized (DatabaseHelper.class) {
                if (existingVulnMap.size() == 0) {
                    int vulnId;
                    String cveId, description, createdDate;
                    int existAtNvd, existAtMitre;
                    existingVulnMap = new HashMap<>();
                    try (Connection connection = dataSource.getConnection()) {

                        String selectSql = "SELECT vuln_id, cve_id, description, created_date, exists_at_nvd, exists_at_mitre from vulnerability";
                        PreparedStatement pstmt = connection.prepareStatement(selectSql);
                        ResultSet rs = pstmt.executeQuery();

                        while (rs.next()) {
                            vulnId = rs.getInt("vuln_id");
                            cveId = rs.getString("cve_id");
                            description = rs.getString("description");
                            createdDate = rs.getString("created_date");
                            existAtNvd = rs.getInt("exists_at_nvd");
                            existAtMitre = rs.getInt("exists_at_mitre");
                            Vulnerability existingVulnInfo = new Vulnerability(vulnId, cveId, description, existAtNvd, existAtMitre,
                                    createdDate);
                            existingVulnMap.put(cveId, existingVulnInfo);
                        }
                        log.info("NVIP has loaded {} existing CVE items from DB!", existingVulnMap.size());
                    } catch (Exception e) {
                        log.error("Error while getting existing vulnerabilities from DB\nException: {}", e.getMessage());
                        log.error(
                                "This is a serious error! NVIP will not be able to decide whether to insert or update! Exiting...");
                        System.exit(1);
                    }
                }
            }
        } else {
            log.warn("NVIP has loaded {} existing CVE items from memory!", existingVulnMap.size());
        }

        return existingVulnMap;
    }

    /**
     * Collect a CVE ID from the Vulnerability table by Vuln ID
     *
     * @param vulnId
     * @return
     */
    public String getCveId(String vulnId) {

        String cve_id = "";

        try (Connection connection = dataSource.getConnection()) {

            PreparedStatement pstmt = connection.prepareStatement(selectCVEIdSql);
            pstmt.setInt(1, Integer.parseInt(vulnId));
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                cve_id = rs.getString("cve_id");
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        return cve_id;
    }


    private static final String INSERT_DESCRIPTION = "INSERT INTO description (description, created_date, gpt_func, cve_id, is_user_generated) VALUES (?, ?, ?, ?, ?)";
    private static final String INSERT_JT = "INSERT INTO rawdescriptionjt (description_id, raw_description_id) VALUES (?, ?)";
    private static final String INSERT_VULN_VERSION = "INSERT INTO vulnerabilityversion (cve_id, description_id, created_date, published_date, last_modified_date) VALUES (?, ?, NOW(), ?, ?)";
    private static final String COPY_PREV_VERSION_KEYS = "UPDATE vulnerabilityversion SET vdo_set_id = (SELECT vdo_set_id FROM vulnerabilityversion WHERE cve_id = ? ORDER BY created_date DESC LIMIT 1), " +
            "cpe_set_id = (SELECT cpe_set_id FROM vulnerabilityversion WHERE cve_id = ? ORDER BY created_date DESC LIMIT 1) WHERE vuln_version_id = ?";
    private static final String INSERT_VULNERABILITY = "INSERT INTO vulnerability (cve_id, created_date, vuln_version_id) VALUES (?, NOW(), ?)";
    private static final String UPDATE_VULNERABILITY = "UPDATE vulnerability SET vuln_version_id = ? WHERE cve_id = ?";
    private static final String DELETE_JOB = "DELETE FROM cvejobtrack WHERE cve_id = ?";


    /**
     * Inserts, updates, or does nothing for a composite vulnerability based on its reconciliation status
     * @param vuln composite vulnerability
     * @return 1 if inserted/updated, 0 if skipped, -1 if error
     */
    public int insertOrUpdateVulnerabilityFull(CompositeVulnerability vuln) {
        boolean isUpdate;
        switch (vuln.getReconciliationStatus()) {
            case UPDATED:
                isUpdate = true;
                break;
            case NEW:
                isUpdate = false;
                break;
            default:
                return 0;
        }


        try (Connection conn = dataSource.getConnection();
             PreparedStatement descriptionStatement = conn.prepareStatement(INSERT_DESCRIPTION, Statement.RETURN_GENERATED_KEYS);
             PreparedStatement jtStatement = conn.prepareStatement(INSERT_JT);
             PreparedStatement vvStatement = conn.prepareStatement(INSERT_VULN_VERSION, Statement.RETURN_GENERATED_KEYS);
             PreparedStatement copyStatement = conn.prepareStatement(COPY_PREV_VERSION_KEYS);
             PreparedStatement vulnStatement = conn.prepareStatement(isUpdate ? UPDATE_VULNERABILITY : INSERT_VULNERABILITY);
             PreparedStatement jobStatement = conn.prepareStatement(DELETE_JOB)) {
            // handle all these atomically
            conn.setAutoCommit(false);
            // insert into description table
            populateDescriptionInsert(descriptionStatement, vuln.getSystemDescription());
            descriptionStatement.executeUpdate();
            // get generated description id
            ResultSet rs = descriptionStatement.getGeneratedKeys();
            if (rs.next()) {
                vuln.setDescriptionId(rs.getInt(1));
            } else {
                // Pretty sure an exception would have been thrown by now anyway, but just in case...
                log.error("ERROR: Failure in inserting to the description table");
                throw new SQLException();
            }
            // batch insert into joint table
            for (RawVulnerability rawVuln : vuln.getComponents()) {
                populateJTInsert(jtStatement, vuln.getSystemDescription(), rawVuln);
                jtStatement.addBatch();
            }
            jtStatement.executeBatch();
            // insert new version row
            populateVulnVersionInsert(vvStatement, vuln);
            vvStatement.executeUpdate();
            rs = vvStatement.getGeneratedKeys();
            if (rs.next()) {
                vuln.setVersionId(rs.getInt(1));
            }
            // if we're updating, copy over the vdo/cpe pointers to this new version
            if (isUpdate) {
                populateCopyStatement(copyStatement, vuln);
                copyStatement.executeUpdate();
            }
            // insert new vuln row or update version pointer
            if (isUpdate) {
                populateVulnUpdate(vulnStatement, vuln);
            } else {
                populateVulnInsert(vulnStatement, vuln);
            }
            vulnStatement.executeUpdate();
            // remove job
            populateJobDelete(jobStatement, vuln);
            jobStatement.executeUpdate();
            // execute atomically
            conn.commit();
        } catch (SQLException ex) {
            log.error("ERROR while {} {}.\n{}", isUpdate ? "updating" : "inserting", vuln.getCveId(), ex);
            return -1;
        }
        return 1;
    }

    private void populateDescriptionInsert(PreparedStatement descriptionStatement, CompositeDescription compDesc) throws SQLException {
        descriptionStatement.setString(1, compDesc.getDescription());
        descriptionStatement.setTimestamp(2, compDesc.getCreatedDate());
        descriptionStatement.setString(3, compDesc.getBuildString());
        descriptionStatement.setString(4, compDesc.getCveId());
        descriptionStatement.setInt(5, compDesc.isUserGenerated() ? 1 : 0);
    }

    private void populateJTInsert(PreparedStatement jtStatement, CompositeDescription compDesc, RawVulnerability rawVuln) throws SQLException {
        jtStatement.setInt(1, compDesc.getId());
        jtStatement.setInt(2, rawVuln.getId());
    }

    private void populateVulnInsert(PreparedStatement vulnStatement, CompositeVulnerability vuln) throws SQLException {
        vulnStatement.setString(1, vuln.getCveId());
        vulnStatement.setInt(2, vuln.getVersionId());
    }

    private void populateVulnUpdate(PreparedStatement vulnStatement, CompositeVulnerability vuln) throws SQLException {
        vulnStatement.setInt(1, vuln.getVersionId());
        vulnStatement.setString(2, vuln.getCveId());
    }

    private void populateVulnVersionInsert(PreparedStatement vvStatement, CompositeVulnerability vuln) throws SQLException{
        vvStatement.setString(1, vuln.getCveId());
        vvStatement.setInt(2, vuln.getDescriptionId());
        vvStatement.setTimestamp(3, vuln.getPublishDate());
        vvStatement.setTimestamp(4, vuln.getLastModifiedDate());
    }

    private void populateCopyStatement(PreparedStatement copyStatement, CompositeVulnerability vuln) throws SQLException{
        copyStatement.setString(1, vuln.getCveId());
        copyStatement.setString(2, vuln.getCveId());
        copyStatement.setInt(3, vuln.getVersionId());
    }

    private void populateJobDelete(PreparedStatement jobStatement, CompositeVulnerability vuln) throws SQLException {
        jobStatement.setString(1, vuln.getCveId());
    }
}
