package edu.rit.se.nvip.model;

import edu.rit.se.nvip.cwe.CWE;

import java.sql.Timestamp;
import java.time.Clock;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Model representing a formalized vulnerability, i.e. a row in the vulnerability table complete with the components and instructinos to build its description
 */
public class CompositeVulnerability extends Vulnerability {

    public enum ReconciliationStatus {
        NEW, UNCHANGED, UPDATED;
    }

    public enum NvdStatus {
        IN_NVD(1),
        NOT_IN_NVD(0);

        public final int status;
        NvdStatus(int status) {
            this.status = status;
        }
        public int getStatus(NvdStatus status){
            if(status.equals(IN_NVD)){
                return 1;
            }
            return 0;
        }
    }
//    public enum MitreStatus {
//        IN_MITRE(1),
//        NOT_IN_MITRE(0);
//
//        public final int status;
//        MitreStatus(int status) {
//            this.status = status;
//        }
//        public int getStatus(MitreStatus status){
//            if(status.equals(IN_MITRE)){
//                return 1;
//            }
//            return 0;
//        }
//    }

    // characterized VDO label(s)
    private final List<VdoCharacteristic> vdoCharacteristic = new ArrayList<>();

    // cvss scoring
    private CvssScore cvssScore;

    // affected releases
    private final List<AffectedRelease> affectedReleases = new ArrayList<>();

    //list of related cwes
    private final List<CWE> cweList = new ArrayList<>();
    private ReconciliationStatus recStatus;
    private CompositeDescription compositeDescription;
    private int id;
    private String sourceDomainName;
    private Set<RawVulnerability> potentialSources;

    public static Clock CLOCK = Clock.systemDefaultZone();

    /**
     * Builds a compvuln from existing fields, likely to be used when pulling from the database
     * @param cveId String id e.g. CVE-1234-567
     * @param id integer id, primary key in the vulnerability table
     * @param compositeDescription CompositeDescription object representing the associated row in the description table
     * @param publishDate Earliest publish date among associated sources
     * @param lastModifiedDate Last modified date among associated sources
     * @param createDate Date this vulnerability was initially formalized
     */
    public CompositeVulnerability(String cveId, int id, CompositeDescription compositeDescription, Timestamp publishDate, Timestamp lastModifiedDate, Timestamp createDate) {
        super(cveId, compositeDescription.getDescription(), publishDate, lastModifiedDate, createDate);
        this.id = id;
        this.recStatus = ReconciliationStatus.UNCHANGED;
        this.compositeDescription = compositeDescription;
    }

    /**
     * NEW composite vulnerability formed from fields of a raw vulnerability
     * @param rawVuln Raw vulnerability from a webpage
     */
    public CompositeVulnerability(RawVulnerability rawVuln) {
        this(rawVuln.getCveId(), 0, new CompositeDescription(rawVuln), rawVuln.getPublishDate(), rawVuln.getLastModifiedDate(), new Timestamp(currentTime()));
        this.recStatus = ReconciliationStatus.NEW;
    }

    /**
     * NEW composite vulnerability from a list of new raw vulnerabilities. Used when many new sources are found but no formalization exists yet
     * @param rawVulns list of raw vulnerabilities
     * @param reconciledDescription the description formed from the set of vulnerabilities // TODO build from a compositedescription object instead?
     * @return a CompositeVulnerability based on new sources and no previously existing composite vulnerability
     */
    public static CompositeVulnerability fromSet(Set<RawVulnerability> rawVulns, String reconciledDescription) {
        RawVulnerability sampleVuln = rawVulns.iterator().next();
        Timestamp current = new Timestamp(currentTime());
        CompositeDescription compDes = new CompositeDescription(sampleVuln.getCveId(), reconciledDescription, rawVulns);
        CompositeVulnerability out = new CompositeVulnerability(sampleVuln.getCveId(), 0, compDes, earliestPubDate(rawVulns), latestModDate(rawVulns), current);
        out.recStatus = ReconciliationStatus.NEW;
        return out;
    }

    public void setRecStatus(ReconciliationStatus rec){
        this.recStatus = rec;
    }
    public List<String> getSourceURLs() {
        return this.potentialSources.stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toList());
    }

    public static void setClock(Clock clock) {
        CLOCK = clock;
    }

    private static long currentTime() {
        return CLOCK.millis();
    }

    public Set<RawVulnerability> getComponents() {
        return this.compositeDescription.getSources();
    }

    public ReconciliationStatus getReconciliationStatus() {
        return this.recStatus;
    }

    public Set<String> getSources() {
        return this.getComponents().stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toSet());
    }

    public List<AffectedRelease> getAffectedReleases() {
        return affectedReleases;
    }

    public List<VdoCharacteristic> getVdoCharacteristic() {
        return vdoCharacteristic;
    }

    public void addVdoCharacteristic(VdoCharacteristic vdoCharacteristic) {
        this.vdoCharacteristic.add(vdoCharacteristic);
    }

    /**
     * Updates the compositedescription to the new description string and additional sources.
     * @param description string description
     * @param rawVulns raw vulnerabilities used to make the description with the buildstring
     */
    public void updateDescription(String description, Set<RawVulnerability> rawVulns, boolean resynth) {
        if ((!description.equals(this.compositeDescription.getDescription())
                || rawVulns.size() > 0)
                && this.recStatus == ReconciliationStatus.UNCHANGED) {
            this.recStatus = ReconciliationStatus.UPDATED;
        }
        if (resynth) {
            this.compositeDescription.addSourcesAndResynth(description, rawVulns);
        }
        else {
            this.compositeDescription.addSources(description, rawVulns);
        }
    }

    public void resetDescription() {
        this.compositeDescription.reset();
        this.recStatus = ReconciliationStatus.UPDATED;
    }

    public boolean usesHighPrio() {
        return this.compositeDescription.usesHighPrio();
    }

    public void setPotentialSources(Set<RawVulnerability> potentialSources) {
        this.potentialSources = potentialSources;
    }

    public void setDescriptionId(int id) {
        this.compositeDescription.setId(id);
    }


    public int getDescriptionId() {
        return this.compositeDescription.getId();
    }

    public String getBuildString() {
        return this.compositeDescription.getBuildString();
    }

    public Timestamp getDescriptionCreateDate() {
        return this.compositeDescription.getCreatedDate();
    }

    @Override
    public String toString() {
        // get sources
        StringBuilder sbSources = new StringBuilder();
        for (RawVulnerability source : this.potentialSources)
            sbSources.append(source.getSourceUrl()).append("\t");

        return "Vulnerability [cveId=" + cveId + ", description=" + description + ", platform=" + platform + ", patch=" + patch + ", publishDate=" + publishDate + ", createDate=" + createDate + ", lastModifydDate="
                + lastModifiedDate + ", fixDate=" + fixDate + ", existInNvd=" + inNvd + ", existInMitre=" + inMitre + ", timeGapNvd=" + timeGapNvd + ", timeGapMitre=" + timeGapMitre + ", sourceURL=" + sbSources
                + ", vdoCharacteristic=" + vdoCharacteristic + ", severity=" + cvssScore + "]";
    }

    public CvssScore getCvssScoreInfo() {
        return cvssScore;
    }

    public void addCvssScore(CvssScore cvss) {
        this.cvssScore = cvss;

    }
    public void addCWE(CWE cwe){
        this.cweList.add(cwe);
    }

    public List<CWE> getCWEs(){
        return cweList;
    }

    @Override
    public String getDescription() {
        return this.compositeDescription.getDescription();
    }

    @Override
    public Timestamp getPublishDate() {
        // we have decided that all sources should feed into publish date reconciliation, not just those contributing to description
        return earliestPubDate(this.potentialSources);
    }

    @Override
    public Timestamp getLastModifiedDate() {
        // we have decided that all sources should feed into mod date reconciliation, not just those contributing to description
        return latestModDate(this.potentialSources);
    }

    public void setTimeGapNvd(double timeGapNvd) {
        this.timeGapNvd = timeGapNvd;
    }

    public void setTimeGapMitre(double timeGapMitre) {
        this.timeGapMitre = timeGapMitre;
    }


    private static Timestamp latestModDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> modDates = rawVulns.stream().map(RawVulnerability::getLastModifiedDate).collect(Collectors.toList());
        return getExtremeTimestamp(modDates, false);
    }

    private static Timestamp earliestPubDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> pubDates = rawVulns.stream().map(RawVulnerability::getPublishDate).collect(Collectors.toList());
        return getExtremeTimestamp(pubDates, true);
    }

    private static Timestamp getExtremeTimestamp(Collection<Timestamp> timestamps, boolean getEarliest) {
        Comparator<Timestamp> c = Comparator.comparingLong(Timestamp::getTime);
        Collection<Timestamp> nonNullStamps = timestamps.stream().filter(Objects::nonNull).collect(Collectors.toList());
        if (nonNullStamps.size() == 0) {
            return null;
        }
        return getEarliest ? Collections.min(nonNullStamps, c) : Collections.max(nonNullStamps, c);
    }
}
