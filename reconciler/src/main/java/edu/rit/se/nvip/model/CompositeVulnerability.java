package edu.rit.se.nvip.model;

import java.sql.Timestamp;
import java.time.Clock;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Model representing a formalized vulnerability, i.e. a row in the vulnerability table complete with the components and instructinos to build its description
 */
public class CompositeVulnerability extends Vulnerability {

    public enum ReconciliationStatus {
        NEW, UNCHANGED, UPDATED;
    }

    public enum NvdStatus {
        IN_NVD, NOT_IN_NVD
    }

    private ReconciliationStatus recStatus;
    private NvdStatus nvdStatus = NvdStatus.NOT_IN_NVD;
    private CompositeDescription compositeDescription;
    private int id;

    public static Clock CLOCK = Clock.systemDefaultZone();

    /**
     * Builds a compvuln from existing fields, likely to be used when pulling from the database
     * @param cveId String id e.g. CVE-1234-567
     * @param id integer id, primary key in the vulnerability table
     * @param compositeDescription CompositeDescription object representing the associated row in the description table
     * @param publishDate Earliest publish date among associated sources
     * @param lastModifiedDate Last modified date among associated sources
     * @param createDate Date this vulnerability was initially formalized
     */
    public CompositeVulnerability(String cveId, int id, CompositeDescription compositeDescription, Timestamp publishDate, Timestamp lastModifiedDate, Timestamp createDate) {
        super(cveId, compositeDescription.getDescription(), publishDate, lastModifiedDate, createDate);
        this.id = id;
        this.recStatus = ReconciliationStatus.UNCHANGED;
        this.compositeDescription = compositeDescription;
    }

    /**
     * NEW composite vulnerability formed from fields of a raw vulnerability
     * @param rawVuln Raw vulnerability from a webpage
     */
    public CompositeVulnerability(RawVulnerability rawVuln) {
        this(rawVuln.getCveId(), 0, new CompositeDescription(rawVuln), rawVuln.getPublishDate(), rawVuln.getLastModifiedDate(), rawVuln.getCreateDate());
        this.recStatus = ReconciliationStatus.NEW;
    }

    /**
     * NEW composite vulnerability from a list of new raw vulnerabilities. Used when many new sources are found but no formalization exists yet
     * @param rawVulns list of raw vulnerabilities
     * @param reconciledDescription the description formed from the set of vulnerabilities // TODO build from a compositedescription object instead?
     * @return a CompositeVulnerability based on new sources and no previously existing composite vulnerability
     */
    public static CompositeVulnerability fromSet(Set<RawVulnerability> rawVulns, String reconciledDescription) {
        RawVulnerability sampleVuln = rawVulns.iterator().next();
        Timestamp current = new Timestamp(currentTime());
        CompositeDescription compDes = new CompositeDescription(sampleVuln.getCveId(), reconciledDescription, rawVulns);
        CompositeVulnerability out = new CompositeVulnerability(sampleVuln.getCveId(), 0, compDes, earliestPubDate(rawVulns), latestModDate(rawVulns), current);
        out.recStatus = ReconciliationStatus.NEW;
        return out;
    }

    public static void setClock(Clock clock) {
        CLOCK = clock;
    }

    private static long currentTime() {
        return CLOCK.millis();
    }

    public Set<RawVulnerability> getComponents() {
        return this.compositeDescription.getSources();
    }

    public ReconciliationStatus getReconciliationStatus() {
        return this.recStatus;
    }

    public Set<String> getSources() {
        return this.getComponents().stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toSet());
    }

    /**
     * Updates the compositedescription to the new description string and additional sources.
     * @param description string description
     * @param rawVulns raw vulnerabilities used to make the description with the buildstring
     */
    public void updateDescription(String description, Set<RawVulnerability> rawVulns, boolean resynth) {
        if ((!description.equals(this.compositeDescription.getDescription())
                || rawVulns.size() > 0)
                && this.recStatus == ReconciliationStatus.UNCHANGED) {
            this.recStatus = ReconciliationStatus.UPDATED;
        }
        if (resynth) {
            this.compositeDescription.addSourcesAndResynth(description, rawVulns);
        }
        else {
            this.compositeDescription.addSources(description, rawVulns);
        }
    }

    public void resetDescription() {
        this.compositeDescription.reset();
        this.recStatus = ReconciliationStatus.UPDATED;
    }

    public boolean usesHighPrio() {
        return this.compositeDescription.usesHighPrio();
    }

    public void setDescriptionId(int id) {
        this.compositeDescription.setId(id);
    }

    public void setNvdStatus(NvdStatus nvdStatus) {
        this.nvdStatus = nvdStatus;
    }

    public int getDescriptionId() {
        return this.compositeDescription.getId();
    }

    public String getBuildString() {
        return this.compositeDescription.getBuildString();
    }

    public Timestamp getDescriptionCreateDate() {
        return this.compositeDescription.getCreatedDate();
    }

    @Override
    public String getDescription() {
        return this.compositeDescription.getDescription();
    }

    @Override
    public Timestamp getPublishDate() {
        return earliestPubDate(this.compositeDescription.getSources());
    }

    @Override
    public Timestamp getLastModifiedDate() {
        return latestModDate(this.compositeDescription.getSources());
    }


    private static Timestamp latestModDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> modDates = rawVulns.stream().map(RawVulnerability::getLastModifiedDate).collect(Collectors.toList());
        return getExtremeTimestamp(modDates, false);
    }

    private static Timestamp earliestPubDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> pubDates = rawVulns.stream().map(RawVulnerability::getPublishDate).collect(Collectors.toList());
        return getExtremeTimestamp(pubDates, true);
    }

    private static Timestamp getExtremeTimestamp(Collection<Timestamp> timestamps, boolean getEarliest) {
        Comparator<Timestamp> c = Comparator.comparingLong(Timestamp::getTime);
        Collection<Timestamp> nonNullStamps = timestamps.stream().filter(Objects::nonNull).collect(Collectors.toList());
        if (nonNullStamps.size() == 0) {
            return null;
        }
        return getEarliest ? Collections.min(nonNullStamps, c) : Collections.max(nonNullStamps, c);
    }
}
