package edu.rit.se.nvip.model;

import edu.rit.se.nvip.cwe.CWE;

import java.sql.Timestamp;
import java.time.Clock;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Model representing a formalized vulnerability, i.e. a row in the vulnerability table complete with the components and instructinos to build its description
 */
public class CompositeVulnerability extends Vulnerability {

    public enum ReconciliationStatus {
        NEW, UNCHANGED, UPDATED;
    }

    private MitreVulnerability mitreVuln;
    private NvdVulnerability nvdVuln;

    // characterized VDO label(s)
    private final List<VdoCharacteristic> vdoCharacteristic = new ArrayList<>();

    // cvss scoring
    private CvssScore cvssScore;

    //list of related cwes
    private final List<CWE> cweList = new ArrayList<>();
    private ReconciliationStatus recStatus;
    private CompositeDescription compositeDescription;
    private int id;
    private Set<RawVulnerability> potentialSources;

    public static Clock CLOCK = Clock.systemDefaultZone();

    /**
     * Builds a compvuln from existing fields, likely to be used when pulling from the database
     * @param cveId String id e.g. CVE-1234-567
     * @param id integer id, primary key in the vulnerability table
     * @param compositeDescription CompositeDescription object representing the associated row in the description table
     * @param publishDate Earliest publish date among associated sources
     * @param lastModifiedDate Last modified date among associated sources
     * @param createDate Date this vulnerability was initially formalized
     */
    public CompositeVulnerability(String cveId, int id, CompositeDescription compositeDescription, Timestamp publishDate, Timestamp lastModifiedDate, Timestamp createDate) {
        super(cveId, compositeDescription.getDescription(), publishDate, lastModifiedDate, createDate);
        this.id = id;
        this.recStatus = ReconciliationStatus.UNCHANGED;
        this.compositeDescription = compositeDescription;
    }

    /**
     * NEW composite vulnerability formed from fields of a raw vulnerability
     * @param rawVuln Raw vulnerability from a webpage
     */
    public CompositeVulnerability(RawVulnerability rawVuln) {
        this(rawVuln.getCveId(), 0, new CompositeDescription(rawVuln), rawVuln.getPublishDate(), rawVuln.getLastModifiedDate(), new Timestamp(currentTime()));
        this.recStatus = ReconciliationStatus.NEW;
    }

    /**
     * NEW composite vulnerability from a list of new raw vulnerabilities. Used when many new sources are found but no formalization exists yet
     * @param rawVulns list of raw vulnerabilities
     * @param reconciledDescription the description formed from the set of vulnerabilities // TODO build from a compositedescription object instead?
     * @return a CompositeVulnerability based on new sources and no previously existing composite vulnerability
     */
    public static CompositeVulnerability fromSet(Set<RawVulnerability> rawVulns, String reconciledDescription) {
        RawVulnerability sampleVuln = rawVulns.iterator().next();
        Timestamp current = new Timestamp(currentTime());
        CompositeDescription compDes = new CompositeDescription(sampleVuln.getCveId(), reconciledDescription, rawVulns);
        CompositeVulnerability out = new CompositeVulnerability(sampleVuln.getCveId(), 0, compDes, earliestPubDate(rawVulns), latestModDate(rawVulns), current);
        out.recStatus = ReconciliationStatus.NEW;
        return out;
    }

    public void setRecStatus(ReconciliationStatus rec){
        this.recStatus = rec;
    }
    public List<String> getSourceURLs() {
        return this.potentialSources.stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toList());
    }

    public static void setClock(Clock clock) {
        CLOCK = clock;
    }

    private static long currentTime() {
        return CLOCK.millis();
    }

    public Set<RawVulnerability> getComponents() {
        return this.compositeDescription.getSources();
    }

    public ReconciliationStatus getReconciliationStatus() {
        return this.recStatus;
    }

    public Set<String> getSources() {
        return this.getComponents().stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toSet());
    }

    public List<VdoCharacteristic> getVdoCharacteristic() {
        return vdoCharacteristic;
    }

    public void addVdoCharacteristic(VdoCharacteristic vdoCharacteristic) {
        this.vdoCharacteristic.add(vdoCharacteristic);
    }

    /**
     * Updates the compositedescription to the new description string and additional sources.
     * @param description string description
     * @param rawVulns raw vulnerabilities used to make the description with the buildstring
     */
    public void updateDescription(String description, Set<RawVulnerability> rawVulns, boolean resynth) {
        if ((!description.equals(this.compositeDescription.getDescription())
                || rawVulns.size() > 0)
                && this.recStatus == ReconciliationStatus.UNCHANGED) {
            this.recStatus = ReconciliationStatus.UPDATED;
        }
        if (resynth) {
            this.compositeDescription.addSourcesAndResynth(description, rawVulns);
        }
        else {
            this.compositeDescription.addSources(description, rawVulns);
        }
    }

    public void resetDescription() {
        this.compositeDescription.reset();
        this.recStatus = ReconciliationStatus.UPDATED;
    }

    public boolean usesHighPrio() {
        return this.compositeDescription.usesHighPrio();
    }

    public void setPotentialSources(Set<RawVulnerability> potentialSources) {
        this.potentialSources = potentialSources;
    }

    public void setDescriptionId(int id) {
        this.compositeDescription.setId(id);
    }


    public int getDescriptionId() {
        return this.compositeDescription.getId();
    }

    public String getBuildString() {
        return this.compositeDescription.getBuildString();
    }

    public Timestamp getDescriptionCreateDate() {
        return this.compositeDescription.getCreatedDate();
    }

    @Override
    public String toString() {
        // get sources
        StringBuilder sbSources = new StringBuilder();
        for (RawVulnerability source : this.potentialSources)
            sbSources.append(source.getSourceUrl()).append("\t");

        return "Vulnerability [cveId=" + cveId + ", description=" + description + ", publishDate=" + publishDate + ", createDate=" + createDate + ", lastModifydDate="
                + lastModifiedDate + ", existInNvd=" + isInNvd() + ", existInMitre=" + isInMitre() + ", timeGapNvd=" + getNvdTimeGap() + ", timeGapMitre=" + getMitreTimeGap() + ", sourceURL=" + sbSources
                + ", vdoCharacteristic=" + vdoCharacteristic + ", severity=" + cvssScore + "]";
    }

    public CvssScore getCvssScoreInfo() {
        return cvssScore;
    }

    public void addCvssScore(CvssScore cvss) {
        this.cvssScore = cvss;

    }
    public void addCWE(CWE cwe){
        this.cweList.add(cwe);
    }

    public List<CWE> getCWEs(){
        return cweList;
    }

    @Override
    public String getDescription() {
        return this.compositeDescription.getDescription();
    }

    @Override
    public Timestamp getPublishDate() {
        // we have decided that all sources should feed into publish date reconciliation, not just those contributing to description
        return earliestPubDate(this.potentialSources);
    }

    @Override
    public Timestamp getLastModifiedDate() {
        // we have decided that all sources should feed into mod date reconciliation, not just those contributing to description
        return latestModDate(this.potentialSources);
    }

    public NvdVulnerability getNvdVuln() {
        return this.nvdVuln;
    }

    public void setNvdVuln(NvdVulnerability nvdVuln) {
        this.nvdVuln = nvdVuln;
    }

    public MitreVulnerability getMitreVuln() {
        return this.mitreVuln;
    }

    public void setMitreVuln(MitreVulnerability mitreVuln) {
        this.mitreVuln = mitreVuln;
    }

    public boolean isInNvd() {
        if (this.nvdVuln == null) {
            return false;
        }
        return nvdVuln.inNvd();
    }

    public boolean isInMitre() {
        if (this.mitreVuln == null) {
            return false;
        }
        return mitreVuln.inMitre();
    }

    /**
     * Computes the time gap between the created date of this composite vulnerability and its associated NVD vulnerability.
     * If there is no NVD vulnerability or the NVD vuln was found first, the gap is reported as 0.
     * This is an arbitrary decision that is subject to change
     * @return Positive time gap if we found it first, 0 if nvd found it first or if they don't have it at all
     */
    public double getNvdTimeGap() {
        double gap;
        if (this.nvdVuln == null) {
            gap = 0; // subject to change
        }
        long ourTime = this.getCreateDate().getTime();
        long theirTime = this.nvdVuln.getPublishDate().getTime();
        gap = theirTime - ourTime;
        return gap/3600./1000.; // milliseconds to hours
    }

    public double getMitreTimeGap() {
        return getNvdTimeGap(); // mitre vulns don't have dates, so we'll just return the nvd gap. subject to change or removal
    }


    private static Timestamp latestModDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> modDates = rawVulns.stream().map(RawVulnerability::getLastModifiedDate).collect(Collectors.toList());
        return getExtremeTimestamp(modDates, false);
    }

    private static Timestamp earliestPubDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> pubDates = rawVulns.stream().map(RawVulnerability::getPublishDate).collect(Collectors.toList());
        return getExtremeTimestamp(pubDates, true);
    }

    private static Timestamp getExtremeTimestamp(Collection<Timestamp> timestamps, boolean getEarliest) {
        Comparator<Timestamp> c = Comparator.comparingLong(Timestamp::getTime);
        Collection<Timestamp> nonNullStamps = timestamps.stream().filter(Objects::nonNull).collect(Collectors.toList());
        if (nonNullStamps.size() == 0) {
            return null;
        }
        return getEarliest ? Collections.min(nonNullStamps, c) : Collections.max(nonNullStamps, c);
    }
}
