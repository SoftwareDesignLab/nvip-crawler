package model;

import java.sql.Timestamp;
import java.time.Clock;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Model representing a formalized vulnerability, i.e. a row in the vulnerability table complete with the components and instructinos to build its description
 */
public class CompositeVulnerability extends Vulnerability {

    /**
     * reconcile status
     */
    public enum CveReconcileStatus {
        DO_NOT_CHANGE, UPDATE, INSERT;
    }

    public enum ReconciliationStatus {
        NEW, UNCHANGED, UPDATED;
    }

    public enum NvdStatus {
        IN_NVD, NOT_IN_NVD
    }
    /**
     * Used for tagging
     */
    private String nvdSearchResult = ""; // the note string the Nvip associated to this CVE
    private String mitreSearchResult = ""; // the note string the Nvip associated to this CVE
    private String nvipNote = ""; // comments added by Nvip

    /**
     * related objects
     */
    // the source URL list (where we found this vulnerability): Does not allow
    // duplicates!
    private final LinkedHashSet<VulnSource> sourceURL = new LinkedHashSet<>();

    // characterized VDO label(s)
    private final List<VdoCharacteristic> vdoCharacteristic = new ArrayList<>();

    // cvss scoring
    private final List<CvssScore> cvssSCore = new ArrayList<>();

    // affected releases
    private final List<AffectedRelease> affectedReleases = new ArrayList<>();

    CveReconcileStatus cveReconcileStatus = model.CompositeVulnerability.CveReconcileStatus.DO_NOT_CHANGE;

    private ReconciliationStatus recStatus;
    private NvdStatus nvdStatus = NvdStatus.NOT_IN_NVD;
    private CompositeDescription compositeDescription;
    private int id;
    private String sourceDomainName;

    public static Clock CLOCK = Clock.systemDefaultZone();

    /**
     * Builds a compvuln from existing fields, likely to be used when pulling from the database
     * @param cveId String id e.g. CVE-1234-567
     * @param id integer id, primary key in the vulnerability table
     * @param compositeDescription CompositeDescription object representing the associated row in the description table
     * @param publishDate Earliest publish date among associated sources
     * @param lastModifiedDate Last modified date among associated sources
     * @param createDate Date this vulnerability was initially formalized
     */
    public CompositeVulnerability(String cveId, int id, CompositeDescription compositeDescription, Timestamp publishDate, Timestamp lastModifiedDate, Timestamp createDate) {
        super(cveId, compositeDescription.getDescription(), publishDate, lastModifiedDate, createDate);
        this.id = id;
        this.recStatus = ReconciliationStatus.UNCHANGED;
        this.compositeDescription = compositeDescription;
    }

    /**
     * NEW composite vulnerability formed from fields of a raw vulnerability
     * @param rawVuln Raw vulnerability from a webpage
     */
    public CompositeVulnerability(RawVulnerability rawVuln) {
        this(rawVuln.getCveId(), 0, new CompositeDescription(rawVuln), rawVuln.getPublishDate(), rawVuln.getLastModifiedDate(), rawVuln.getCreateDate());
        this.recStatus = ReconciliationStatus.NEW;
    }

    /**
     * NEW composite vulnerability from a list of new raw vulnerabilities. Used when many new sources are found but no formalization exists yet
     * @param rawVulns list of raw vulnerabilities
     * @param reconciledDescription the description formed from the set of vulnerabilities // TODO build from a compositedescription object instead?
     * @return a CompositeVulnerability based on new sources and no previously existing composite vulnerability
     */
    public static CompositeVulnerability fromSet(Set<RawVulnerability> rawVulns, String reconciledDescription) {
        RawVulnerability sampleVuln = rawVulns.iterator().next();
        Timestamp current = new Timestamp(currentTime());
        CompositeDescription compDes = new CompositeDescription(sampleVuln.getCveId(), reconciledDescription, rawVulns);
        CompositeVulnerability out = new CompositeVulnerability(sampleVuln.getCveId(), 0, compDes, earliestPubDate(rawVulns), latestModDate(rawVulns), current);
        out.recStatus = ReconciliationStatus.NEW;
        return out;
    }
    public String getCveId() {
        return cveId;
    }

    public List<String> getSourceURL() {
        List<String> sURLs = new ArrayList<>();
        for (VulnSource vulnSource : sourceURL) {
            sURLs.add(vulnSource.getUrl());
        }
        return sURLs;
    }
    public List<VulnSource> getVulnSourceList() {
        return new ArrayList<>(sourceURL);
    }

    public static void setClock(Clock clock) {
        CLOCK = clock;
    }

    private static long currentTime() {
        return CLOCK.millis();
    }

    public Set<RawVulnerability> getComponents() {
        return this.compositeDescription.getSources();
    }

    public ReconciliationStatus getReconciliationStatus() {
        return this.recStatus;
    }

    public Set<String> getSources() {
        return this.getComponents().stream().map(RawVulnerability::getSourceUrl).collect(Collectors.toSet());
    }

    public String getNvdSearchResult() {
        return nvdSearchResult;
    }

    public List<AffectedRelease> getAffectedReleases() {
        return affectedReleases;
    }

    public void setNvdSearchResult(String nvdSearchResult) {
        this.nvdSearchResult = nvdSearchResult;
    }

    public String getMitreSearchResult() {
        return mitreSearchResult;
    }

    public void setMitreSearchResult(String mitreSearchResult) {
        this.mitreSearchResult = mitreSearchResult;
    }

    public String getNvipNote() {
        return nvipNote;
    }

    public List<VdoCharacteristic> getVdoCharacteristic() {
        return vdoCharacteristic;
    }

    public void addVdoCharacteristic(VdoCharacteristic vdoCharacteristic) {
        this.vdoCharacteristic.add(vdoCharacteristic);
    }
    public void setNvipNote(String nvipNote) {
        this.nvipNote = nvipNote;
    }

    /**
     * Updates the compositedescription to the new description string and additional sources.
     * @param description string description
     * @param rawVulns raw vulnerabilities used to make the description with the buildstring
     */
    public void updateDescription(String description, Set<RawVulnerability> rawVulns, boolean resynth) {
        if ((!description.equals(this.compositeDescription.getDescription())
                || rawVulns.size() > 0)
                && this.recStatus == ReconciliationStatus.UNCHANGED) {
            this.recStatus = ReconciliationStatus.UPDATED;
        }
        if (resynth) {
            this.compositeDescription.addSourcesAndResynth(description, rawVulns);
        }
        else {
            this.compositeDescription.addSources(description, rawVulns);
        }

    }

    public void setDescriptionId(int id) {
        this.compositeDescription.setId(id);
    }

    public void setNvdStatus(NvdStatus nvdStatus) {
        this.nvdStatus = nvdStatus;
    }

    public int getDescriptionId() {
        return this.compositeDescription.getId();
    }

    public String getBuildString() {
        return this.compositeDescription.getBuildString();
    }

    public Timestamp getDescriptionCreateDate() {
        return this.compositeDescription.getCreatedDate();
    }

    @Override
    public String toString() {
        // get sources
        StringBuilder sbSources = new StringBuilder();
        for (VulnSource vulnSource : sourceURL)
            sbSources.append(vulnSource.url).append("\t");

        return "Vulnerability [cveId=" + cveId + ", description=" + description + ", platform=" + platform + ", patch=" + patch + ", publishDate=" + publishDate + ", createDate=" + createDate + ", lastModifydDate="
                + lastModifiedDate + ", fixDate=" + fixDate + ", existInNvd=" + statusNvd + ", existInMitre=" + statusMitre + ", timeGapNvd=" + timeGapNvd + ", timeGapMitre=" + timeGapMitre + ", sourceURL=" + sbSources
                + ", nvdSearchResult=" + nvdSearchResult + ", mitreSearchResult=" + mitreSearchResult + ", nvipNote=" + nvipNote + ", vdoCharacteristic=" + vdoCharacteristic + ", severity=" + cvssSCore + "]";
    }

    public List<VdoCharacteristic> getVdoCharacteristicInfo() {
        List<VdoCharacteristic> vdoCharacteristicInfo = new ArrayList<>();
        for (int i = 0; i < getVdoCharacteristic().size(); i++) {
            vdoCharacteristicInfo.add(new VdoCharacteristic(getCveId(), getVdoCharacteristic().get(i).getVdoLabelId(), getVdoCharacteristic().get(i).getVdoConfidence(), getVdoCharacteristic().get(i).getVdoNounGroupId()));
        }
        return vdoCharacteristicInfo;
    }
    public List<CvssScore> getCvssScoreInfo() {
        return cvssSCore;
    }

    public void addCvssScore(CvssScore cvss) {
        this.cvssSCore.add(cvss);

    }
    public CveReconcileStatus getCveReconcileStatus() {
        return cveReconcileStatus;
    }

    public void setCveReconcileStatus(model.CompositeVulnerability.CveReconcileStatus cveReconcileStatus) {
        this.cveReconcileStatus = cveReconcileStatus;
    }

    public String getSourceDomainName() {
        return sourceDomainName;
    }

    public void setSourceDomainName(String sourceDomainName) {
        this.sourceDomainName = sourceDomainName;
    }

    @Override
    public String getDescription() {
        return this.compositeDescription.getDescription();
    }

    @Override
    public Timestamp getPublishDate() {
        return earliestPubDate(this.compositeDescription.getSources());
    }

    @Override
    public Timestamp getLastModifiedDate() {
        return latestModDate(this.compositeDescription.getSources());
    }


    private static Timestamp latestModDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> modDates = rawVulns.stream().map(RawVulnerability::getLastModifiedDate).collect(Collectors.toList());
        return getExtremeTimestamp(modDates, false);
    }

    private static Timestamp earliestPubDate(Collection<RawVulnerability> rawVulns) {
        Collection<Timestamp> pubDates = rawVulns.stream().map(RawVulnerability::getPublishDate).collect(Collectors.toList());
        return getExtremeTimestamp(pubDates, true);
    }

    private static Timestamp getExtremeTimestamp(Collection<Timestamp> timestamps, boolean getEarliest) {
        Comparator<Timestamp> c = Comparator.comparingLong(Timestamp::getTime);
        Collection<Timestamp> nonNullStamps = timestamps.stream().filter(Objects::nonNull).collect(Collectors.toList());
        if (nonNullStamps.size() == 0) {
            return null;
        }
        return getEarliest ? Collections.min(nonNullStamps, c) : Collections.max(nonNullStamps, c);
    }

}
