<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Swift.org - Swift.org security</title>
  
  <meta name="author" content="Apple Inc.">
  <meta name="viewport" content="width=device-width initial-scale=1">
  
  <link rel="license" href="https://www.swift.org/LICENSE.txt">
  <link rel="stylesheet" media="all" href="test-generic_list_parser-swift_files/application.css">
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="https://www.swift.org/favicon.ico">
  <link rel="apple-touch-icon" href="https://www.swift.org/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="57x57" href="https://www.swift.org/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://www.swift.org/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://www.swift.org/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://www.swift.org/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://www.swift.org/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://www.swift.org/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://www.swift.org/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.swift.org/apple-touch-icon-180x180.png">
  <link rel="mask-icon" href="https://www.swift.org/assets/images/icon-swift.svg" color="#F05339">
  

  
  <link rel="canonical" href="https://swift.org/support/security.html">
  

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@SwiftLang">
  
  <meta name="twitter:title" content="Swift.org">
  <meta name="twitter:description" content="Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.">
  

  <meta property="og:site_name" content="Swift.org">
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png">
  
  
  <meta property="og:title" content="Swift.org">
  <meta property="og:url" content="https://swift.org">
  <meta property="og:description" content="Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.">
  
</head>

<body data-color-scheme="light">

<script src="test-generic_list_parser-swift_files/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="https://www.swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="https://www.swift.org/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="https://www.swift.org/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="https://www.swift.org/swift-evolution/">Swift Evolution</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li class="active">
      
        <a href="https://www.swift.org/support/security.html">Security</a>
        
        <ul>
          
          <li><a href="https://www.swift.org/support/security.html#security-process">Security Process</a></li>
          
          <li><a href="https://www.swift.org/support/security.html#security-updates">Security Updates</a></li>
          
        </ul>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="https://www.swift.org/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/lldb/">REPL, Debugger &amp; Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/website/">Swift.org website</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/language-workgroup/">Language Workgroup</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/cxx-interop-workgroup/">C++ Interoperability</a>
        
      </li>
      
      
      <li>
      
        <a href="https://www.swift.org/documentation-workgroup/">Documentation Workgroup</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
  <article class="page">
  <header>
    <h1>Swift.org security</h1>
  </header>

  <h2 id="security-process">Security Process</h2>

<p>For the protection of our community, Swift.org doesn’t disclose, 
discuss, or confirm security issues until our investigation is complete 
and any necessary updates are generally available.</p>

<p>Recent security updates are listed in the <a href="#security-updates">Security Updates</a> section below.</p>

<p>Swift.org security documents reference vulnerabilities by <a href="https://www.cve.org/About/Overview">CVE-ID</a> when possible.</p>

<h3 id="reporting-a-security-or-privacy-vulnerability">Reporting a security or privacy vulnerability</h3>

<p>If you believe you have discovered a security or privacy vulnerability in a Swift.org project, please report it to us.
We welcome reports from everyone, including security researchers, developers, and users.</p>

<p>To report a security or privacy vulnerability, please send an email to <a href="mailto:cve@forums.swift.org">cve@forums.swift.org</a> that includes:</p>

<ul>
  <li>The specific project and software version(s) which you believe are affected</li>
  <li>A description of the behavior you observed as well as the behavior that you expected</li>
  <li>A numbered list of steps required to reproduce the issue and/or a video demonstration, if the steps may be hard to follow</li>
</ul>

<p>Please use <a href="https://www.swift.org/keys/cve-signing-key-1.asc">Swift.org’s CVE PGP key</a> to encrypt sensitive information that you send by email.</p>

<p>You’ll receive an email reply from Swift.org to acknowledge that we 
received your report, and we’ll contact you if we need more information.</p>

<h3 id="how-swiftorg-handles-these-reports">How Swift.org handles these reports</h3>

<p>For the protection of our community, Swift.org doesn’t disclose, 
discuss, or confirm security issues until our investigation is complete 
and any necessary updates are generally available.</p>

<p>Swift.org uses security advisories and our security-announce mailing 
list to publish information about security fixes in our projects and to 
publicly credit people or organizations that have reported security 
issues to us.</p>

<h2 id="security-updates">Security Updates</h2>

<ul>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-9861">CVE-2020-9861</a>
    <p>
    A stack overflow issue existed in Swift for Linux. The issue was 
addressed with improved input validation for dealing with deeply nested 
malicious JSON input.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-24666">CVE-2022-24666</a>
    <p>
    A program using swift-nio-http2 is vulnerable to a denial of service
 attack, caused by a network peer sending a specially crafted HTTP/2 
frame. This attack affects all swift-nio-http2 versions from 1.0.0 to 
1.19.1. This vulnerability is caused by a logical error when parsing a 
HTTP/2 HEADERS frame where the frame contains priority information 
without any other data. This logical error caused confusion about the 
size of the frame, leading to a parsing error. This parsing error 
immediately crashes the entire process. Sending a HEADERS frame with 
HTTP/2 priority information does not require any special permission, so 
any HTTP/2 connection peer may send such a frame. For clients, this 
means any server to which they connect may launch this attack. For 
servers, anyone they allow to connect to them may launch such an attack.
 The attack is low-effort: it takes very little resources to send an 
appropriately crafted frame. The impact on availability is high: 
receiving the frame immediately crashes the server, dropping all 
in-flight connections and causing the service to need to restart. It is 
straightforward for an attacker to repeatedly send appropriately crafted
 frames, so attackers require very few resources to achieve a 
substantial denial of service. The attack does not have any 
confidentiality or integrity risks in and of itself: swift-nio-http2 is 
parsing the frame in memory-safe code, so the crash is safe. However, 
sudden process crashes can lead to violations of invariants in services,
 so it is possible that this attack can be used to trigger an error 
condition that has confidentiality or integrity risks. The risk can be 
mitigated if untrusted peers can be prevented from communicating with 
the service. This mitigation is not available to many services. The 
issue is fixed by rewriting the parsing code to correctly handle the 
condition. The issue was found by automated fuzzing by oss-fuzz.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-24667">CVE-2022-24667</a>
    <p>
    A program using swift-nio-http2 is vulnerable to a denial of service
 attack, caused by a network peer sending a specially crafted 
HPACK-encoded header block. This attack affects all swift-nio-http2 
versions from 1.0.0 to 1.19.1. There are a number of implementation 
errors in the parsing of HPACK-encoded header blocks that allow 
maliciously crafted HPACK header blocks to cause crashes in processes 
using swift-nio-http2. Each of these crashes is triggered instead of an 
integer overflow. A malicious HPACK header block could be sent on any of
 the HPACK-carrying frames in a HTTP/2 connection (HEADERS and 
PUSH_PROMISE), at any position. Sending a HPACK header block does not 
require any special permission, so any HTTP/2 connection peer may send 
one. For clients, this means any server to which they connect may launch
 this attack. For servers, anyone they allow to connect to them may 
launch such an attack. The attack is low-effort: it takes very little 
resources to send an appropriately crafted field block. The impact on 
availability is high: receiving a frame carrying this field block 
immediately crashes the server, dropping all in-flight connections and 
causing the service to need to restart. It is straightforward for an 
attacker to repeatedly send appropriately crafted field blocks, so 
attackers require very few resources to achieve a substantial denial of 
service. The attack does not have any confidentiality or integrity risks
 in and of itself: swift-nio-http2 is parsing the field block in 
memory-safe code and the crash is triggered instead of an integer 
overflow. However, sudden process crashes can lead to violations of 
invariants in services, so it is possible that this attack can be used 
to trigger an error condition that has confidentiality or integrity 
risks. The risk can be mitigated if untrusted peers can be prevented 
from communicating with the service. This mitigation is not available to
 many services. The issue is fixed by rewriting the parsing code to 
correctly handle all conditions in the function. The principal issue was
 found by automated fuzzing by oss-fuzz, but several associated bugs in 
the same code were found by code audit and fixed at the same time.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-24668">CVE-2022-24668</a>
    <p>
    A program using swift-nio-http2 is vulnerable to a denial of service
 attack caused by a network peer sending ALTSVC or ORIGIN frames. This 
attack affects all swift-nio-http2 versions from 1.0.0 to 1.19.1. This 
vulnerability is caused by a logical error after frame parsing but 
before frame handling. ORIGIN and ALTSVC frames are not currently 
supported by swift-nio-http2, and should be ignored. However, one code 
path that encounters them has a deliberate trap instead. This was left 
behind from the original development process and was never removed. 
Sending an ALTSVC or ORIGIN frame does not require any special 
permission, so any HTTP/2 connection peer may send such a frame. For 
clients, this means any server to which they connect may launch this 
attack. For servers, anyone they allow to connect to them may launch 
such an attack. The attack is low-effort: it takes very little resources
 to send one of these frames. The impact on availability is high: 
receiving the frame immediately crashes the server, dropping all 
in-flight connections and causing the service to need to restart. It is 
straightforward for an attacker to repeatedly send these frames, so 
attackers require very few resources to achieve a substantial denial of 
service. The attack does not have any confidentiality or integrity risks
 in and of itself. This is a controlled, intentional crash. However, 
sudden process crashes can lead to violations of invariants in services,
 so it is possible that this attack can be used to trigger an error 
condition that has confidentiality or integrity risks. The risk can be 
mitigated if untrusted peers can be prevented from communicating with 
the service. This mitigation is not available to many services. The 
issue is fixed by rewriting the parsing code to correctly handle the 
condition. The issue was found by automated fuzzing by oss-fuzz.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0618">CVE-2022-0618</a>
    <p>
    A program using swift-nio-http2 is vulnerable to a denial of service
 attack, caused by a network peer sending a specially crafted HTTP/2 
frame.
This vulnerability is caused by a logical error when parsing a HTTP/2 
HEADERS or HTTP/2 PUSH_PROMISE frame where the frame contains padding 
information without any other data. This logical error caused confusion 
about the size of the frame, leading to a parsing error. This parsing 
error immediately crashes the entire process.
Sending a HEADERS frame or PUSH_PROMISE frame with HTTP/2 padding 
information does not require any special permission, so any HTTP/2 
connection peer may send such a frame. For clients, this means any 
server to which they connect may launch this attack. For servers, anyone
 they allow to connect to them may launch such an attack.
The attack is low-effort: it takes very little resources to send an 
appropriately crafted frame. The impact on availability is high: 
receiving the frame immediately crashes the server, dropping all 
in-flight connections and causing the service to need to restart. It is 
straightforward for an attacker to repeatedly send appropriately crafted
 frames, so attackers require very few resources to achieve a 
substantial denial of service.
The attack does not have any confidentiality or integrity risks in and 
of itself: swift-nio-http2 is parsing the frame in memory-safe code, so 
the crash is safe. However, sudden process crashes can lead to 
violations of invariants in services, so it is possible that this attack
 can be used to trigger an error condition that has confidentiality or 
integrity risks.
The risk can be mitigated if untrusted peers can be prevented from 
communicating with the service. This mitigation is not available to many
 services.
The issue is fixed by rewriting the parsing code to correctly handle the
 condition. The issue was found by automated fuzzing by oss-fuzz.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-1642">CVE-2022-1642</a>
    <p>
    A program using swift-corelibs-foundation is vulnerable to a denial 
of service attack caused by a potentially malicious source producing a 
JSON document containing a type mismatch.
This vulnerability is caused by the interaction between a 
deserialization mechanism offered by the Swift standard library, the 
Codable protocol; and the JSONDecoder class offered by 
swift-corelibs-foundation, which can deserialize types that adopt the 
Codable protocol based on the content of a provided JSON document. When a
 type that adopts Codable requests the initialization of a field with an
 integer value, the JSONDecoder class uses a type-erased container with 
different accessor methods to attempt and coerce a corresponding JSON 
value and produce an integer. In the case the JSON value was a numeric 
literal with a floating-point portion, JSONDecoder used different 
type-eraser methods during validation than it did during the final 
casting of the value. The checked casting produces a deterministic crash
 due to this mismatch.
The JSONDecoder class is often wrapped by popular Swift-based web 
frameworks to parse the body of HTTP requests and perform basic type 
validation. This makes the attack low-effort: sending a specifically 
crafted JSON document during a request to these endpoints will cause 
them to crash.
The attack does not have any confidentiality or integrity risks in and 
of itself; the crash is produced deterministically by an abort function 
that ensures that execution does not continue in the face of this 
violation of assumptions. However, unexpected crashes can lead to 
violations of invariants in services, so it's possible that this attack 
can be used to trigger error conditions that escalate the risk. 
Producing a denial of service may also be the goal of an attacker in 
itself.
This issue is solved in Swift 5.6.2 for Linux and Windows. This issue 
was solved by ensuring that the same methods are invoked both when 
validating and during casting, so that no type mismatch occurs.
Swift for Linux and Windows versions are not ABI-interchangeable. To 
upgrade a service, its owner must update to this version of the Swift 
toolchain, then recompile and redeploy their software. The new version 
of Swift includes an updated swift-corelibs-foundation package.
Versions of Swift running on Darwin-based operating systems are not 
affected.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3215">CVE-2022-3215</a>
    <p>
    NIOHTTP1 and projects using it for generating HTTP responses can be 
subject to a HTTP Response Injection attack. This occurs when a HTTP/1.1
 server accepts user generated input from an incoming request and 
reflects it into a HTTP/1.1 response header in some form. A malicious 
user can add newlines to their input (usually in encoded form) and 
"inject" those newlines into the returned HTTP response.

This capability allows users to work around security headers and 
HTTP/1.1 framing headers by injecting entirely false responses or other 
new headers. The injected false responses may also be treated as the 
response to subsequent requests, which can lead to XSS, cache poisoning,
 and a number of other flaws.
This issue was resolved by adding validation to the HTTPHeaders type, 
ensuring that there's no whitespace incorrectly present in the HTTP 
headers provided by users. As the existing API surface is non-failable, 
all invalid characters are replaced by linear whitespace.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3252">CVE-2022-3252</a>
    <p>
    Improper detection of complete HTTP body decompression

SwiftNIO Extras provides a pair of helpers for transparently 
decompressing received HTTP request or response bodies. These two 
objects (HTTPRequestDecompressor and HTTPResponseDecompressor) both 
failed to detect when the decompressed body was considered complete. If 
trailing junk data was appended to the HTTP message body, the code would
 repeatedly attempt to decompress this data and fail. This would lead to
 an infinite loop making no forward progress, leading to livelock of the
 system and denial-of-service.

This issue can be triggered by any attacker capable of sending a 
compressed HTTP message. Most commonly this is HTTP servers, as 
compressed HTTP messages cannot be negotiated for HTTP requests, but it 
is possible that users have configured decompression for HTTP requests 
as well. The attack is low effort, and likely to be reached without 
requiring any privilege or system access. The impact on availability is 
high: the process immediately becomes unavailable but does not 
immediately crash, meaning that it is possible for the process to remain
 in this state until an administrator intervenes or an automated circuit
 breaker fires. If left unchecked this issue will very slowly exhaust 
memory resources due to repeated buffer allocation, but the buffers are 
not written to and so it is possible that the processes will not 
terminate for quite some time.

This risk can be mitigated by removing transparent HTTP message 
decompression.

The issue is fixed by correctly detecting the termination of the 
compressed body as reported by zlib and refusing to decompress further 
data. The issue was found by Vojtech Rylko 
(https://github.com/vojtarylko) and reported publicly on GitHub.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-0040">CVE-2023-0040</a>
    <p>
    Versions of Async HTTP Client prior to 1.13.2 are vulnerable to a 
form of targeted request manipulation called CRLF injection. This 
vulnerability was the result of insufficient validation of HTTP header 
field values before sending them to the network. Users are vulnerable if
 they pass untrusted data into HTTP header field values without prior 
sanitisation. Common use-cases here might be to place usernames from a 
database into HTTP header fields.

This vulnerability allows attackers to inject new HTTP header fields, or
 entirely new requests, into the data stream. This can cause requests to
 be understood very differently by the remote server than was intended. 
In general, this is unlikely to result in data disclosure, but it can 
result in a number of logical errors and other misbehaviours.
    </p>
  </li>
  
  <li>
    <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-3918">CVE-2022-3918</a>
    <p>
    A program using FoundationNetworking in swift-corelibs-foundation is
 potentially vulnerable to CRLF (
) injection in URLRequest headers. In this vulnerability, a client can 
insert one or several CRLF sequences into a URLRequest header value. 
When that request is sent via URLSession to an HTTP server, the server 
may interpret the content after the CRLF as extra headers, or even a 
second request. For example, consider a URLRequest to 
http://example.com/ with the GET method. Suppose we set the URLRequest 
header "Foo" to the value "Bar
Extra-Header: Added

GET /other HTTP/1.1". When this request is sent, it will appear to the 
server as two requests:

GET / HTTP/1.1
Foo: Bar
Extra-Header: Added

GET /other HTTP/1.1

In this manner, the client is able to inject extra headers and craft an 
entirely new request to a separate path, despite only making one API 
call in URLSession. If a developer has total control over the request 
and its headers, this vulnerability may not pose a threat. However, this
 vulnerability escalates if un-sanitized user input is placed in header 
values. If so, a malicious user could inject new headers or requests to 
an intermediary or backend server. Developers should be especially 
careful to sanitize user input in this case, or upgrade their version of
 swift-corelibs-foundation to include the patch below.
    </p>
  </li>
  
</ul>

</article>

</main>

<footer role="contentinfo">
  <div class="footer-content">
    
    <p class="copyright">Copyright © 2023 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="https://www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="https://www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form class="color-scheme-toggle" role="radiogroup" tabindex="0" id="color-scheme-toggle">
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto" checked="checked">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="https://www.swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="test-generic_list_parser-swift_files/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>

<script src="test-generic_list_parser-swift_files/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>

<!-- /metrics -->


</body></html>